import * as marked from 'marked';

declare type HtmlModifier = (html: HTMLElement) => void | Promise<void>;
declare type AstModifier = (tokens: marked.TokensList) => marked.TokensList | Promise<marked.TokensList>;
declare type RendererModifier = (renderer: marked.Renderer) => marked.Renderer | Promise<marked.Renderer>;
declare type TokenizerModifier = (
    tokenizer: marked.Tokenizer
) => marked.Tokenizer | Promise<marked.Tokenizer>;

// TODO Use services like Renderer2 instead of direct access to global document object.

/**
 * Nge markdown api to contribute.
 */
export class NgeMarkdown {

    private readonly astModifiers: AstModifier[] = [];
    private readonly htmlModifiers: HtmlModifier[] = [];
    private readonly rendererModifiers: RendererModifier[] = [];
    private readonly tokeniserModifiers: TokenizerModifier[] = [];

    /**
     * Registers a function to call to update the ast generated by the markdown compiler.
     * @param compute the function to call.
     */
    addAstModifier(compute: AstModifier) {
        if (compute == null) {
            throw new ReferenceError('argument "compute" is required');
        }

        this.astModifiers.push(compute);
    }

    /**
     * Registers a function to call to compute the html generated by the markdown compiler.
     * @param compute the function to call.
     */
    addHtmlModifier(compute: HtmlModifier) {
        if (compute == null) {
            throw new ReferenceError('argument "compute" is required');
        }

        this.htmlModifiers.push(compute);
    }

    /**
     * Registers a function to call to update marked library renderer.
     * @param compute the function to call.
     */
    addRendererModifier(compute: RendererModifier) {
        if (compute == null) {
            throw new ReferenceError('argument "compute" is required');
        }

        this.rendererModifiers.push(compute);
    }

    /**
     * Registers a function to call to update marked library tokenizer.
     * @param compute the function to call.
     */
    addTokenizerModifier(compute: TokenizerModifier) {
        if (compute == null) {
            throw new ReferenceError('argument "compute" is required');
        }

        this.tokeniserModifiers.push(compute);
    }

    /**
     * Apply the registered ast modifier functions to the given ast.
     * @param ast the ast to compute.
     * @returns the computed ast.
     */
    async computeAst(ast: marked.TokensList): Promise<marked.TokensList> {
        if (ast == null) {
            throw new ReferenceError('argument "tokens" is required');
        }

        for (const compute of this.astModifiers) {
            ast = await compute(ast);
        }

        return ast;
    }

    /**
     * Apply the registered html modifier functions to the given html.
     * @param element the html element to compute.
     * @returns the computed html.
     */
    async computeHtml(element: HTMLElement): Promise<HTMLElement> {
        if (element == null) {
            throw new ReferenceError('argument "html" is required');
        }

        for (const compute of this.htmlModifiers) {
            await compute(element);
        }

        return element;
    }

    /**
     * Apply the registered renderer modifier functions to the given renderer.
     * @param renderer the renderer to compute.
     * @returns the computed renderer.
     */
    async computeRenderer(renderer: marked.Renderer): Promise<marked.Renderer> {
        if (renderer == null) {
            throw new ReferenceError('argument "renderer" is required');
        }

        for (const compute of this.rendererModifiers) {
            renderer = await compute(renderer);
        }

        return renderer;
    }

    /**
     * Apply the registered tokenizer modifier functions to the given tokenizer.
     * @param tokenizer the tokenizer to compute.
     * @returns the computed tokenizer.
     */
    async computeTokenizer(tokenizer: marked.Tokenizer): Promise<marked.Tokenizer> {
        if (tokenizer == null) {
            throw new ReferenceError('argument "tokenizer" is required');
        }

        for (const compute of this.tokeniserModifiers) {
            tokenizer = await compute(tokenizer);
        }

        return tokenizer;
    }

    /**
     * Add new stylesheet element to the document.
     * @param url url to the stylesheet.
     * @returns A promise that resolves once the element is loaded.
     */
    addStyle(url: string) {
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = url;
        document.body.appendChild(link);
        return new Promise<any>((resolve, reject) => {
            link.onload = resolve;
            link.onerror = reject;
        });
    }

    /**
     * Add new script element to the document.
     * @param url url to the script.
     * @returns A promise that resolves once the element is loaded.
     */
    addScript(url: string) {
        const script = document.createElement('script');
        script.type = 'text/javascript';
        script.src = url;
        document.body.appendChild(script);
        return new Promise<any>((resolve, reject) => {
            script.onload = resolve;
            script.onerror = reject;
        });
    }

    /**
     * Gets the list of declared css selectors (classes, ids...)
     */
    getDeclaredCssSelectors() {
        const selectors: string[] = [];
        for (const sheet of Array.from(document.styleSheets)) {
            console.log(sheet);
            const rules = (sheet as CSSStyleSheet).rules;
            if (rules) {
                for (const rule of Array.from(rules)) {
                    selectors.push((rule as CSSStyleRule).selectorText);
                }
            }
        }
        return selectors;
    }
}
