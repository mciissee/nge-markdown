import * as marked from 'marked';
import { InjectionToken } from '@angular/core';

declare type HtmlModifier = (html: HTMLElement) => void;
declare type AstModifier = (tokens: marked.TokensList) => marked.TokensList;
declare type RendererModifier = (renderer: marked.Renderer) => marked.Renderer;
declare type TokenizerModifier = (
    tokenizer: marked.Tokenizer
) => marked.Tokenizer;

export class NgeMarkdownModifier {

    private readonly astModifiers: AstModifier[] = [];
    private readonly htmlModifiers: HtmlModifier[] = [];
    private readonly rendererModifiers: RendererModifier[] = [];
    private readonly tokeniserModifiers: TokenizerModifier[] = [];

    /**
     * Registers a function to call to update the ast generated by the markdown compiler.
     * @param compute the function to call.
     */
    addAstModifier(compute: AstModifier) {
        if (compute == null) {
            throw new ReferenceError('argument "compute" is required');
        }

        this.astModifiers.push(compute);
    }

    /**
     * Registers a function to call to compute the html generated by the markdown compiler.
     * @param compute the function to call.
     */
    addHtmlModifier(compute: HtmlModifier) {
        if (compute == null) {
            throw new ReferenceError('argument "compute" is required');
        }

        this.htmlModifiers.push(compute);
    }

    /**
     * Registers a function to call to update marked library renderer.
     * @param compute the function to call.
     */
    addRendererModifier(compute: RendererModifier) {
        if (compute == null) {
            throw new ReferenceError('argument "compute" is required');
        }

        this.rendererModifiers.push(compute);
    }

    /**
     * Registers a function to call to update marked library tokenizer.
     * @param compute the function to call.
     */
    addTokenizerModifier(compute: TokenizerModifier) {
        if (compute == null) {
            throw new ReferenceError('argument "compute" is required');
        }

        this.tokeniserModifiers.push(compute);
    }

    /**
     * Apply the registered ast modifier functions to the given ast.
     * @param ast the ast to compute.
     * @returns the computed ast.
     */
    computeAst(ast: marked.TokensList): marked.TokensList {
        if (ast == null) {
            throw new ReferenceError('argument "tokens" is required');
        }

        for (const compute of this.astModifiers) {
            ast = compute(ast);
        }

        return ast;
    }

    /**
     * Apply the registered html modifier functions to the given html.
     * @param html the html to compute.
     * @returns the computed html.
     */
    computeHtml(html: HTMLElement): HTMLElement {
        if (html == null) {
            throw new ReferenceError('argument "html" is required');
        }

        for (const compute of this.htmlModifiers) {
            compute(html);
        }

        return html;
    }

    /**
     * Apply the registered renderer modifier functions to the given renderer.
     * @param renderer the renderer to compute.
     * @returns the computed renderer.
     */
    computeRenderer(renderer: marked.Renderer): marked.Renderer {
        if (renderer == null) {
            throw new ReferenceError('argument "renderer" is required');
        }

        for (const compute of this.rendererModifiers) {
            renderer = compute(renderer);
        }

        return renderer;
    }

    /**
     * Apply the registered tokenizer modifier functions to the given tokenizer.
     * @param tokenizer the tokenizer to compute.
     * @returns the computed tokenizer.
     */
    computeTokenizer(tokenizer: marked.Tokenizer): marked.Tokenizer {
        if (tokenizer == null) {
            throw new ReferenceError('argument "tokenizer" is required');
        }

        for (const compute of this.tokeniserModifiers) {
            tokenizer = compute(tokenizer);
        }

        return tokenizer;
    }
}

export interface NgeMarkdownConfig {
    markedOptions?: marked.MarkedOptions;
}

export const NGE_MARKDOWN_CONFIG = new InjectionToken<NgeMarkdownConfig>(
    'NGE_MARKDOWN_CONFIG'
);
