import * as marked from 'marked';
import { InjectionToken } from '@angular/core';

declare type HtmlModifier = (html: HTMLElement) => void | Promise<void>;
declare type AstModifier = (tokens: marked.TokensList) => marked.TokensList | Promise<marked.TokensList>;
declare type RendererModifier = (renderer: marked.Renderer) => marked.Renderer | Promise<marked.Renderer>;
declare type TokenizerModifier = (
    tokenizer: marked.Tokenizer
) => marked.Tokenizer | Promise<marked.Tokenizer>;

export class NgeMarkdownModifier {

    private readonly astModifiers: AstModifier[] = [];
    private readonly htmlModifiers: HtmlModifier[] = [];
    private readonly rendererModifiers: RendererModifier[] = [];
    private readonly tokeniserModifiers: TokenizerModifier[] = [];

    /**
     * Registers a function to call to update the ast generated by the markdown compiler.
     * @param compute the function to call.
     */
    addAstModifier(compute: AstModifier) {
        if (compute == null) {
            throw new ReferenceError('argument "compute" is required');
        }

        this.astModifiers.push(compute);
    }

    /**
     * Registers a function to call to compute the html generated by the markdown compiler.
     * @param compute the function to call.
     */
    addHtmlModifier(compute: HtmlModifier) {
        if (compute == null) {
            throw new ReferenceError('argument "compute" is required');
        }

        this.htmlModifiers.push(compute);
    }

    /**
     * Registers a function to call to update marked library renderer.
     * @param compute the function to call.
     */
    addRendererModifier(compute: RendererModifier) {
        if (compute == null) {
            throw new ReferenceError('argument "compute" is required');
        }

        this.rendererModifiers.push(compute);
    }

    /**
     * Registers a function to call to update marked library tokenizer.
     * @param compute the function to call.
     */
    addTokenizerModifier(compute: TokenizerModifier) {
        if (compute == null) {
            throw new ReferenceError('argument "compute" is required');
        }

        this.tokeniserModifiers.push(compute);
    }

    /**
     * Apply the registered ast modifier functions to the given ast.
     * @param ast the ast to compute.
     * @returns the computed ast.
     */
    async computeAst(ast: marked.TokensList): Promise<marked.TokensList> {
        if (ast == null) {
            throw new ReferenceError('argument "tokens" is required');
        }

        for (const compute of this.astModifiers) {
            ast = await compute(ast);
        }

        return ast;
    }

    /**
     * Apply the registered html modifier functions to the given html.
     * @param element the html element to compute.
     * @returns the computed html.
     */
    async computeHtml(element: HTMLElement): Promise<HTMLElement> {
        if (element == null) {
            throw new ReferenceError('argument "html" is required');
        }

        for (const compute of this.htmlModifiers) {
            await compute(element);
        }

        return element;
    }

    /**
     * Apply the registered renderer modifier functions to the given renderer.
     * @param renderer the renderer to compute.
     * @returns the computed renderer.
     */
    async computeRenderer(renderer: marked.Renderer): Promise<marked.Renderer> {
        if (renderer == null) {
            throw new ReferenceError('argument "renderer" is required');
        }

        for (const compute of this.rendererModifiers) {
            renderer = await compute(renderer);
        }

        return renderer;
    }

    /**
     * Apply the registered tokenizer modifier functions to the given tokenizer.
     * @param tokenizer the tokenizer to compute.
     * @returns the computed tokenizer.
     */
    async computeTokenizer(tokenizer: marked.Tokenizer): Promise<marked.Tokenizer> {
        if (tokenizer == null) {
            throw new ReferenceError('argument "tokenizer" is required');
        }

        for (const compute of this.tokeniserModifiers) {
            tokenizer = await compute(tokenizer);
        }

        return tokenizer;
    }

}

export interface NgeMarkdownConfig {
    markedOptions?: marked.MarkedOptions;
}

export const NGE_MARKDOWN_CONFIG = new InjectionToken<NgeMarkdownConfig>(
    'NGE_MARKDOWN_CONFIG'
);
